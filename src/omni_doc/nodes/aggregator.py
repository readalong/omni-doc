"""Aggregator node for generating markdown report and posting comments."""

from typing import Optional

from omni_doc.github.commenter import PRCommenter
from omni_doc.models.state import OmniDocState
from omni_doc.utils.logging import get_logger, GitHubAPIError
from omni_doc.utils.markdown import (
    format_collapsible,
    format_finding,
    format_mermaid_diagram,
    format_table,
)

logger = get_logger(__name__)

# Comment header
COMMENT_HEADER = """# Omni-Doc Analysis Report

*Automated documentation analysis for this pull request.*

"""

# Comment footer
COMMENT_FOOTER = """

---
*Generated by [Omni-Doc](https://github.com/readalong/omni-doc) - AI-powered documentation analysis*
"""


async def generate_markdown(state: OmniDocState) -> dict:
    """Generate markdown report from analysis findings.

    This node:
    1. Collects all findings and agent outputs
    2. Groups findings by type and severity
    3. Generates a formatted markdown report
    4. Includes diagrams if present

    Args:
        state: Current workflow state with findings

    Returns:
        State update with markdown_report
    """
    findings = state.get("findings", [])
    agent_outputs = state.get("agent_outputs", [])
    pr_metadata = state.get("pr_metadata", {})
    file_changes = state.get("file_changes", [])
    documentation_status = state.get("documentation_status")
    enable_diagrams = state.get("enable_diagrams", True)

    logger.info(f"Generating markdown report ({len(findings)} findings)")

    # Check if we should use comprehensive report format
    docs_missing = (
        documentation_status is None
        or documentation_status.get("status") == "missing"
    )

    try:
        if docs_missing:
            # Use comprehensive format for repos lacking documentation
            markdown_report = _generate_comprehensive_docs_report(
                pr_metadata=pr_metadata,
                file_changes=file_changes,
                findings=findings,
                agent_outputs=agent_outputs,
                enable_diagrams=enable_diagrams,
            )
        else:
            # Use standard incremental format for repos with documentation
            markdown_report = _generate_incremental_report(
                pr_metadata=pr_metadata,
                findings=findings,
                agent_outputs=agent_outputs,
                enable_diagrams=enable_diagrams,
            )

        logger.info(f"Generated report: {len(markdown_report)} characters")

        return {"markdown_report": markdown_report}

    except Exception as e:
        logger.exception("Error generating markdown report")
        return {
            "markdown_report": _generate_error_report(str(e)),
            "errors": [f"Error generating report: {str(e)}"],
        }


def _generate_incremental_report(
    pr_metadata: dict,
    findings: list[dict],
    agent_outputs: list[dict],
    enable_diagrams: bool,
) -> str:
    """Generate standard incremental report for repos with documentation.

    Args:
        pr_metadata: PR metadata
        findings: List of findings
        agent_outputs: List of agent outputs
        enable_diagrams: Whether diagrams are enabled

    Returns:
        Formatted markdown report
    """
    parts = [COMMENT_HEADER]

    # Summary section
    parts.append(_generate_summary(findings, pr_metadata))

    # Findings by severity (this now includes recommended updates inline)
    if findings:
        parts.append(_generate_findings_section(findings))
    else:
        parts.append("## No Documentation Issues Found\n")
        parts.append("Great job! No documentation issues were detected in this PR.\n")

    # Diagrams section (if enabled and present)
    if enable_diagrams:
        diagrams = _collect_diagrams(findings, agent_outputs)
        if diagrams:
            parts.append(_generate_diagrams_section(diagrams))

    parts.append(COMMENT_FOOTER)

    return "\n".join(parts)


def _generate_comprehensive_docs_report(
    pr_metadata: dict,
    file_changes: list[dict],
    findings: list[dict],
    agent_outputs: list[dict],
    enable_diagrams: bool,
) -> str:
    """Generate comprehensive report for repos lacking documentation.

    This format:
    1. Shows brief PR change summary at top
    2. Displays mermaid diagrams prominently
    3. Puts generated documentation in collapsible details block

    Args:
        pr_metadata: PR metadata
        file_changes: List of file changes
        findings: List of findings
        agent_outputs: List of agent outputs
        enable_diagrams: Whether diagrams are enabled

    Returns:
        Formatted markdown report
    """
    parts = [COMMENT_HEADER]

    # Summary section with warning
    parts.append("## Summary\n")
    parts.append(f"**PR:** {pr_metadata.get('title', 'Unknown')}")
    parts.append(f"**Author:** @{pr_metadata.get('author', 'unknown')}")
    parts.append("")
    parts.append(":warning: **This repository lacks documentation.**")
    parts.append("")

    # What this PR changes
    parts.append("### What This PR Changes")
    if file_changes:
        added = sum(1 for f in file_changes if f.get("status") == "added")
        modified = sum(1 for f in file_changes if f.get("status") == "modified")
        removed = sum(1 for f in file_changes if f.get("status") == "removed")
        change_parts = []
        if added:
            change_parts.append(f"Added {added} file(s)")
        if modified:
            change_parts.append(f"Modified {modified} file(s)")
        if removed:
            change_parts.append(f"Removed {removed} file(s)")
        parts.append(f"- **{', '.join(change_parts)}**: {', '.join(f['filename'] for f in file_changes[:5])}")
        if len(file_changes) > 5:
            parts.append(f"  - ...and {len(file_changes) - 5} more files")
    parts.append("")

    # Architecture Overview with diagrams prominently displayed
    if enable_diagrams:
        diagrams = _collect_diagrams(findings, agent_outputs)
        if diagrams:
            parts.append("## Architecture Overview\n")
            for diagram in diagrams:
                title = diagram.get("title", "Diagram")
                description = diagram.get("description", "")
                code = diagram.get("diagram", "")

                parts.append(f"### {title}\n")
                if description:
                    parts.append(f"{description}\n")
                parts.append(format_mermaid_diagram(code))
                parts.append("")

    # Generated Documentation in collapsible section
    generated_docs = _extract_generated_documentation(agent_outputs)
    if generated_docs:
        parts.append(format_collapsible(
            "Project Documentation",
            generated_docs,
        ))
        parts.append("")

    # Brief findings summary (if any non-doc-missing findings)
    non_missing_findings = [f for f in findings if f.get("finding_type") != "missing_doc"]
    if non_missing_findings:
        parts.append("## Additional Findings\n")
        for finding in non_missing_findings[:5]:
            parts.append(format_finding(
                finding_type=finding.get("finding_type", "unknown"),
                title=finding.get("title", "Untitled"),
                description=finding.get("description", ""),
                severity=finding.get("severity", "info"),
                file_path=finding.get("file_path"),
                suggestion=finding.get("suggestion"),
            ))
            parts.append("")

    parts.append(COMMENT_FOOTER)

    return "\n".join(parts)


def _extract_generated_documentation(agent_outputs: list[dict]) -> str:
    """Extract generated documentation content from agent outputs.

    Args:
        agent_outputs: List of agent outputs

    Returns:
        Combined documentation content
    """
    doc_parts = []

    for output in agent_outputs:
        if output.get("agent_name") == "technical_writer":
            content = output.get("content", "")
            if content:
                doc_parts.append(content)

    return "\n\n".join(doc_parts)


async def post_github_comment(state: OmniDocState) -> dict:
    """Post the analysis report as a GitHub comment.

    This node:
    1. Checks if dry_run mode is enabled
    2. Posts or updates the Omni-Doc comment on the PR
    3. Returns the comment URL

    Args:
        state: Current workflow state with markdown_report

    Returns:
        State update with comment_url
    """
    dry_run = state.get("dry_run", False)
    markdown_report = state.get("markdown_report")
    pr_metadata = state.get("pr_metadata")

    if not markdown_report:
        logger.warning("No markdown report to post")
        return {}

    if not pr_metadata:
        logger.error("No PR metadata available")
        return {"errors": ["No PR metadata available for commenting"]}

    if dry_run:
        logger.info("Dry run mode - skipping comment post")
        return {"comment_url": "[dry-run]"}

    owner = pr_metadata["owner"]
    repo = pr_metadata["repo"]
    pr_number = pr_metadata["pr_number"]

    logger.info(f"Posting comment to {owner}/{repo}#{pr_number}")

    try:
        commenter = PRCommenter()
        comment_url = await commenter.update_or_create_comment(
            owner=owner,
            repo=repo,
            pr_number=pr_number,
            body=markdown_report,
        )

        logger.info(f"Comment posted: {comment_url}")
        return {"comment_url": comment_url}

    except GitHubAPIError as e:
        logger.error(f"Failed to post comment: {e}")
        return {"errors": [f"Failed to post comment: {e.message}"]}
    except Exception as e:
        logger.exception("Unexpected error posting comment")
        return {"errors": [f"Unexpected error posting comment: {str(e)}"]}


def _generate_summary(findings: list[dict], pr_metadata: dict) -> str:
    """Generate summary section of the report.

    Args:
        findings: List of findings
        pr_metadata: PR metadata

    Returns:
        Markdown summary section
    """
    parts = ["## Summary\n"]

    # PR info
    parts.append(f"**PR:** {pr_metadata.get('title', 'Unknown')}")
    parts.append(f"**Author:** @{pr_metadata.get('author', 'unknown')}")
    parts.append("")

    # Count by severity
    severity_counts = {}
    for finding in findings:
        sev = finding.get("severity", "info")
        severity_counts[sev] = severity_counts.get(sev, 0) + 1

    # Count by type
    type_counts = {}
    for finding in findings:
        ftype = finding.get("finding_type", "other")
        type_counts[ftype] = type_counts.get(ftype, 0) + 1

    if findings:
        # Summary table
        headers = ["Metric", "Count"]
        rows = [
            ["Total Findings", str(len(findings))],
            [":red_circle: Critical", str(severity_counts.get("critical", 0))],
            [":orange_circle: High", str(severity_counts.get("high", 0))],
            [":yellow_circle: Medium", str(severity_counts.get("medium", 0))],
            [":white_circle: Low", str(severity_counts.get("low", 0))],
            [":blue_circle: Info", str(severity_counts.get("info", 0))],
        ]
        parts.append(format_table(headers, rows))
        parts.append("")

        # Type breakdown
        type_items = [f"**{k}:** {v}" for k, v in sorted(type_counts.items())]
        parts.append("**By Type:** " + " | ".join(type_items))
    else:
        parts.append(":white_check_mark: **No documentation issues found!**")

    parts.append("")
    return "\n".join(parts)


def _generate_findings_section(findings: list[dict]) -> str:
    """Generate the main findings section.

    Args:
        findings: List of findings

    Returns:
        Markdown findings section
    """
    parts = ["## Findings\n"]

    # Group by severity
    severity_order = ["critical", "high", "medium", "low", "info"]
    findings_by_severity: dict[str, list[dict]] = {s: [] for s in severity_order}

    for finding in findings:
        sev = finding.get("severity", "info")
        if sev in findings_by_severity:
            findings_by_severity[sev].append(finding)
        else:
            findings_by_severity["info"].append(finding)

    # Output findings by severity
    for severity in severity_order:
        severity_findings = findings_by_severity[severity]
        if not severity_findings:
            continue

        for finding in severity_findings:
            parts.append(format_finding(
                finding_type=finding.get("finding_type", "unknown"),
                title=finding.get("title", "Untitled"),
                description=finding.get("description", ""),
                severity=finding.get("severity", "info"),
                file_path=finding.get("file_path"),
                target_section=finding.get("target_section"),
                recommended_update=finding.get("recommended_update"),
            ))
            parts.append("")

    return "\n".join(parts)


def _generate_diagrams_section(diagrams: list[dict]) -> str:
    """Generate the diagrams section.

    Args:
        diagrams: List of diagram records

    Returns:
        Markdown diagrams section
    """
    parts = ["## Architecture Diagrams\n"]

    for i, diagram in enumerate(diagrams, 1):
        title = diagram.get("title", f"Diagram {i}")
        code = diagram.get("diagram", "")
        description = diagram.get("description", "")

        parts.append(f"### {title}\n")
        if description:
            parts.append(f"{description}\n")
        parts.append(format_mermaid_diagram(code))
        parts.append("")

    return "\n".join(parts)


def _collect_diagrams(
    findings: list[dict],
    agent_outputs: list[dict],
) -> list[dict]:
    """Collect all diagrams from findings.

    Deduplicates based on diagram code content.

    Args:
        findings: List of findings
        agent_outputs: List of agent outputs (kept for signature compatibility)

    Returns:
        List of unique diagram records
    """
    diagrams = []
    seen_diagrams: set[str] = set()

    # Collect diagrams from findings only (agent outputs no longer contain diagram code)
    for finding in findings:
        diagram_code = finding.get("diagram")
        if diagram_code and diagram_code not in seen_diagrams:
            seen_diagrams.add(diagram_code)
            diagrams.append({
                "title": finding.get("title", "Generated Diagram"),
                "diagram": diagram_code,
                "description": finding.get("description", ""),
            })

    return diagrams


def _generate_error_report(error: str) -> str:
    """Generate an error report when something goes wrong.

    Args:
        error: Error message

    Returns:
        Markdown error report
    """
    return f"""{COMMENT_HEADER}
## Analysis Error

An error occurred during the documentation analysis:

```
{error}
```

Please check the logs for more details.
{COMMENT_FOOTER}"""
